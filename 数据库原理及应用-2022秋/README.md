# 数据库期末复习

---
<aside>
💡 期末考试

1. 填空题，20个，20分
2. 设计题，10分
    1. E-R模型
    2. 逻辑模型
3. 应用题，8-9题，70分
    1. 数据库三级模式
    2. 数据逻辑三要素
    3. 事务（一致性、原子性、隔离性、持久性）
    4. 实际数据库应用
        1. 创建数据库——完整性约束（参照、实体、非空约束、级联策略）
        2. 关系代数和SQL语言
        3. 索引、视图
        4. 权限
        5. 事务并发和恢复（不同隔离级别事务并发，加锁，恢复策略，检查点建立）
</aside>

---

- [数据库期末复习](#数据库期末复习)
- [第一章 数据库系统概论](#第一章-数据库系统概论)
  - [1.1 数据与数据库](#11-数据与数据库)
  - [1.2 数据库管理技术](#12-数据库管理技术)
  - [1.3 数据模式](#13-数据模式)
- [第二章 关系模型和关系代数](#第二章-关系模型和关系代数)
  - [2.1 数据模型](#21-数据模型)
  - [2.2 关系模型](#22-关系模型)
  - [2.3 关系代数](#23-关系代数)
- [第三章 数据库设计过程和方法](#第三章-数据库设计过程和方法)
  - [3.1 数据库设计](#31-数据库设计)
  - [3.2 概念设计](#32-概念设计)
  - [3.3 逻辑设计和物理设计](#33-逻辑设计和物理设计)
- [第四章 实体联系E-R模型](#第四章-实体联系e-r模型)
  - [4.1 E-R模型表示](#41-e-r模型表示)
  - [4.2 数量关系与转换（同一实体型内部也可以）](#42-数量关系与转换同一实体型内部也可以)
  - [4.3 分E-R图设计与合并](#43-分e-r图设计与合并)
- [第五章 规范化](#第五章-规范化)
  - [5.1 模式设计问题](#51-模式设计问题)
  - [5.2 函数依赖](#52-函数依赖)
  - [5.3 Amstrong公理](#53-amstrong公理)
  - [5.4 模式分解](#54-模式分解)
  - [5.5 关系范式](#55-关系范式)
- [第六章 SQL语言](#第六章-sql语言)
- [第七章 事务与并发控制](#第七章-事务与并发控制)
  - [7.1 事务并发](#71-事务并发)
  - [7.2 可串行化调度](#72-可串行化调度)
  - [7.3 基于锁的并发控制](#73-基于锁的并发控制)
- [第八章 故障恢复](#第八章-故障恢复)
  - [8.1 数据库恢复技术](#81-数据库恢复技术)
  - [8.2 故障种类及恢复策略](#82-故障种类及恢复策略)
- [第九章 数据库安全](#第九章-数据库安全)
  - [9.1 数据库安全概述](#91-数据库安全概述)
  - [9.2 自主访问控制（DAC）](#92-自主访问控制dac)
  - [9.3 强制访问控制（MAC）](#93-强制访问控制mac)


# 第一章 数据库系统概论

## 1.1 数据与数据库

**数据相关概念**

- **数据**是计算机能够识别、存储和处理的符号
- **信息**是经过加工处理的数据，是数据的具体含义
- **知识**是有用的信息

**数据库DB**

- 数据库是长期储存在计算机内、有组织的、可共享的大量数据集合

**数据库管理系统DBMS**

- 一个能够让用户定义、创建和维护数据库以及控制对数据库访问的软件系统

**DBMS主要功能**

- 数据库定义DDL：对各级数据模式精确定义，包括创建模式、数据库、表、视图
- 数据操作DML：对数据库中数据处理，包括增、删、改、查
- 数据库运行控制DCL：数据库恢复、并发控制、完整性控制、安全性控制
- 数据库维护
- 数据字典DD：存放数据库三级模式的描述

**数据库系统DBS**

- 引入数据库后的计算机系统
- 组成：硬件、软件（DB、DBMS和其他相关软件）、用户（数据库管理员、开发者、普通用户）

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled.png)

## 1.2 数据库管理技术

**发展阶段**

- 人工管理
- 文件系统管理
- 数据库系统管理

**数据库技术分类**

- 网状数据库、层次数据库、关系型数据库、非关系型数据库
- 关系数据库不足：不满足非结构化数据处理需求，不支持复杂数据分析

## 1.3 数据模式

**模式与实例**

- 模式（Schema）：数据库逻辑结构和特征的描述，反映数据的结构及其联系，相对稳定的
- 实例（Instance）：模式的一个具体值，反映某一时刻状态，可变化，有多个
- 类似于“型”和“值”

**数据库三级模式**

|  | 含义 | 位置 | 个数 | 定义内容 | 对象 |
| --- | --- | --- | --- | --- | --- |
| 模式（概念模式、逻辑模式）Conceptual Schema | 数据库中全体数据的逻辑结构和特征的描述
所有用户的公共数据视图，综合了所有用户的需求 | 中间层 ，与物理存储无关，与具体应用程序无关 | 一个 | 逻辑结构；数据联系；安全性、完整性要求；DDL描述；表结构 | 由DBA（数据库管理员）决定 |
| 外模式（子模式、用户模式）External Schema | 数据库用户使用的局部数据的逻辑结构和特征的描述；模式的子集或变形，与某一应用有关的数据的逻辑表示；
SQL定义的视图 | 模式与应用之间 | 多个 | 同一数据外模式中结构、类型、长度均可不同 | 面向应用程序与最终用户 |
| 内模式（存储模式）Internal Schema | 是数据物理结构和存储方式的描述；
是数据在数据库内部的表示方式 | 物理存储 | 一个 |  | 基于DBMS定义 |

**模式映射**

- 外模式/模式映射：逻辑独立性（外部模式不受概念模式变化影响），不唯一
- 模式/内模式映射：物理独立性（概念模式不受内部模式变化的影响），唯一
- **补充：数据库管理员DBA职责**
    - DBA的主要任务之一是数据库设计，具体地说是进行数据模式的设计；数据库维护。DBA必须对数据库中的数据安全性、完整性、并发控制及系统恢复、数据定期转储等进行实施与维护；改善系统性能，提高系统效率。DBA必须随时监视数据库的运行状态，不断调整内部结构，使系统保持最佳状态与效率。

# 第二章 关系模型和关系代数

## 2.1 数据模型

**数据模型**用来抽象、表示和处理现实世界中的数据和信息，是现实世界的模拟

**数据模型的不同层次**

1. 概念模型（CDM）
    - 面向世界建模，用来描述现实世界的概念化结构，与DBMS无关
2. 逻辑模型（LDM）
    - 面向用户与系统建模，用户从数据库看到的数据模型，DBMS支持的模型
    - 一般DBMS支持一种LDM
    - **逻辑模型的类型**
        - 层次模型
        - 网状模型
        - 关系模型
        - 非关系型模型（半结构化、键值对、文档型、列存、图）
3. 物理数据模型（PDM）
    - 面向具体的DBMS，面向机器
    - 描述数据在存储介质的组织结构

**数据模型三要素**

- 数据结构：域、属性、关系、对象等，对系统静态特征描述
- 数据操作：检索和更新，对系统动态特征描述
- 约束条件：完整性约束

**数据库体系结构**

- 单机架构
- 主备架构
- 主从架构
- 多主架构
- Share-Nothing
- Shared-Disk

## 2.2 关系模型

💡 **关系** 是笛卡尔积的有一定意义的有限子集

**关系实例**

- 关系实例是由命名的若干行和列组成的表格，一般关系指代实例。

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%201.png)

**关系模式**

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%202.png)

**关系数据库**

- 关系的有限集合
- 由关系模式（数据库模式）与关系实例构成（数据库实例）

**数据结构**

- 键：关系中能唯一区分不同元组的属性或属性组合，称为关系的一个键，或者称为关键字、码。关键字的属性值不能取“NULL”。
- 候选键：凡在关系中能够唯一区分确定不同元组的属性或属性组合，称为候选健。包括在候选键中的属性成为**主属性**，不包括在候选键中的属性称为**非主属性。**
- 主键：从多个候选键中选出一个关系作为主键
- 外键：关系中某个属性或属性组合并非该关系的键，但却是另一个关系的主键，称此属性或属性组合组合为本关系的外键

**数据约束：完整性约束**

- 实体完整性：主码不为空
- 参照完整性：外码取值：1）空；2）被参照关系表中某个元组的主码值
- 用户定义完整性

**关系数据库优缺点**

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%203.png)

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%204.png)

## 2.3 关系代数

**集合运算**

**并运算：** $ \ bigcup $  R1和R2必须相容：属性数目相同，属性域相同，语义一致

**差运算**： $ - $   R1和R2相容

**交运算**：$ \bigcap $ &#x2003;  $R\bigcap S=R-(R-S)$

**笛卡尔积**： $ R\times S $ .

**选择运算**

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%205.png)

**投影运算**

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%206.png)

**连接**

**等值连接**

**自然连接**

**外连接** ：左外连接（LJN）、右外连接（RJN）、全外连接

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%207.png)

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%208.png)

**重命名运算 $\rho_{R}(S)$** 

**除法运算**

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%209.png)

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2010.png)

 用选择、投影、笛卡尔积和差表示除法

$ R\div S=\Pi_X(R)-\Pi_X(\Pi_X(R)\times\Pi_Y(S)-\Pi_X(R)) $


# 第三章 数据库设计过程和方法

## 3.1 数据库设计

**数据库设计**：根据用户需求研制数据库结构的过程

- 数据库结构设计：静态，包括各个过程（概念、逻辑、物理）
- 数据库行为设计：动态

**设计方法**

- 直观设计方法（手工试凑法）
- 新奥尔良法
- 基于实体-关系模型的设计方法
- 3NF设计方法、面向对象的数据库设计方法、计算机辅助工具

**设计过程**

1. 需求分析
2. 概念设计
3. 逻辑设计
4. 物理设计
5. 实现
6. 运行与维护

## 3.2 概念设计

**目的**：生成概念模型；真实充分反映现实世界，易于理解更改和转换。

**概念数据模型（CDM）**

- 面向用户、面向客观世界的模型
- 用来描述现实世界的概念化结构，与具体DBMS无关
- 概念数据模型必须转换成逻辑数据模型才能在DBMS中实现

**设计方法**

- 自顶向下：总分方式将大的逐步分解为更详细的小模式
- 逐步扩张：层状扩展
- 自底向上：局部概念模式，组合成全局模式

**数据抽象**

- 分类
- 聚集
- 概况

## 3.3 逻辑设计和物理设计

**逻辑设计：** 将全局E-R图转换为DBMS支持的数据模型，用关系规范化理论对关系数据模型进行优化。

**物理设计**

- 存储结构设计：存放位置，系统配置
- 存取方式设计：聚簇、索引、HASH

# 第四章 实体联系E-R模型

## 4.1 E-R模型表示

- 实体：方框
- 属性：椭圆。属性必须是不可分的（不包括其他属性），不能与其他实体有联系，实体与属性选择优先属性
    - 属性可以嵌套
    - 多值属性用双椭圆表示
    - 多值属性可以分解为弱实体，弱实体用双方框，联系用双菱形
    - 派生属性（其他属性推导）用虚线椭圆
- 联系：菱形

## 4.2 数量关系与转换（同一实体型内部也可以）

- 一对一联系：可以转换为一个关系模式，也可以与任一端合并
- 一对多联系：可以转换为一个关系模型，也可以与n端合并
- 多对多联系：转换为一个关系模式

## 4.3 分E-R图设计与合并

1. 选择局部应用
2. 逐一设计分E-R图
3. 集合E-R图
    1. 合并，解决冲突
    2. 修改和重构，消除冗余：利用函数依赖
    3. 验证计提概念模型
- 属性冲突：属性值类型、域
- 命名冲突：同名异义、异名同义
- 结构冲突：同一对象在不同应用中具有不同抽象，属性个数不同

# 第五章 规范化

## 5.1 模式设计问题

**模型设计问题**

- 数据冗余：浪费存储空间，引起异常
- 操作异常：更新异常、删除异常、插入异常

> 模式分解解决

## 5.2 函数依赖

**数据依赖类型**

- 多值依赖
- 函数依赖：值一个关系表中 **属性** 之间的联系，属性之间在语义上的关联

**函数依赖定义**

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2011.png)

**函数依赖分类**

- 平凡函数依赖：$ Y\subseteq X $ ，Y函数依赖于X。函数依赖一般都指 **非平凡** 函数依赖
- 部分函数依赖与完全函数依赖
    
    ![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2012.png)
    
- 传递函数依赖
    
    X，Y，Z是三个不同的属性(集)
    若X→Y，Y→Z，但Y→X不成立，则有X→Z
    
    Z传递依赖于X,Trivial Functional Dependency
    

**函数依赖与码**

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2013.png)

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2014.png)

## 5.3 Amstrong公理

- 自反性（Reflexivity）
    
    $
    Y \subseteq X \subseteq U, 则X \rightarrow Y成立
    $
    
- 增广性（Augmentation）
    
    $
    X \rightarrow Y成立，且Z \subseteq U,则XZ \rightarrow YZ
    $
    
- 传递性（Transitivity）
    
    $
    X\rightarrow Y,Y \rightarrow Z成立，则X \rightarrow Z成立
    $
    

**属性集闭包**

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2015.png)

**最小依赖集$F_{min}$**

- $ F_{min}^+=F^+ $
- 每个函数依赖右边为单属性（在求出最小依赖后可以合并）
- 没有冗余函数依赖
- 每个函数依赖左边没有冗余属性

**最小依赖集计算**

[****求最小依赖集****](https://www.notion.so/58edf08c051f4968986bf3f4e5784e3b) 

## 5.4 模式分解

**无损分解——数据等价**

- 定义
    
    ![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2016.png)
    
- 判断——Chase方法
    
    [无损连接性判断-chase](https://www.notion.so/chase-49a01ab53a204b1886dc51e3f70c1a0f) 
    
    [无损连接性+保持依赖+3NF分解+BCNF分解](https://blog.csdn.net/weixin_41744192/article/details/105910865)
    

**保持函数依赖——依赖等价**

- 定义
    
    ![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2017.png)
    
- 判断
    
    ![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2018.png)
    

## 5.5 关系范式

要求除了与元组进行连接的外键外，数据库实例中的其他属性的值都不能被复制

**1NF：** 每个属性值都是不可再分的原子值

**2NF：** 属于1NF，且每个**非主属性完全函数依赖**于**候选码**（无非主属性部分函数依赖）

- R的码单码，R属于2NF
- R的码是全码，R属于2NF
- R是二元关系，R属于2NF

**2NF分解算法**

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2019.png)

**3NF：**属于1NF，且每个**非主属性**不**传递依赖**于**候选码**（无非主属性传递依赖）

- 如果R是3NF，那么R也是2NF

**3NF分解算法（无损且保持依赖）**

1. 求最小依赖集。先求出R的最小依赖集，可得F={A ->D,E->D,D->B,BC->D,DC->A}
2. 依赖两侧未出现，分成子集放一边。首先可以发现没有不出现在两侧的元素不用单独分出一个子集，“**剩余依赖变子集**”然后我们将各依赖分别划分为子集得到：{AD} {ED} {DB} {BCD} {DCA}，即为所求保持函数依赖的3NF分解
3. 若要连接成无损，再添**候选**做子集。（由于**候选码为(CE)**因此将**CE->B**划分出子集（BCE）)
    
    候选码的求解：所谓候选码即能决定整个关系的，我们通过找**未出现在依赖右边**的和**两侧均未出现**的元素即可求得。
    
    ![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2020.png)
    

**BCFN：**属于1NF，且**属性**不**传递依赖**于**候选码**（包括主属性的传递依赖）

- 所有非主属性对每一个码完全函数依赖
- 所有主属性对每一个不包含它的码完全函数依赖
- 没有任何属性完全函数依赖于非码的任何一组属性

**BCFN保存依赖分解**

1. 先求最小依赖集。最小依赖集为F={B->G,CE->B,C->A,B->D,C->D}。
2. **候码,非码**成子集。由于**候选码为(CE)**因此将**CE→B**划分出子集（BCE），而B→G，B->D左侧均不含主属性(C、E)中的任何一个故划分出(BG),(BD）
3. 此时剩余依赖F={C->A,C->D}剩余元素{A,C,D}检查发现函数依赖左侧都是候选码即完成BCNF分解，如果不满足则继续分解余下的。

**反范式**：提高查询效率，采用空间换时间的思路

# 第六章 SQL语言

[SQL语法](https://www.notion.so/SQL-40ee35f2e95b42b4b2bdb502ebf3d3d4) 

[数据模式/完整性约束](https://www.notion.so/ddd22e539afd48e8b4b62a77caf4fedb) ：模式、完整性约束、游标/触发器/存储过程/函数

# 第七章 事务与并发控制

## 7.1 事务并发

**问题**

- 产生不一致结果
- 并发执行错误
- 何时更新数据库

**事务**

- 是用户定义的一个数据库操作序列
- 这些操作要么全做要么全不做
- 是一个不可分割的工作单位
- 一个事务可以是一条SQL语句、一组SQL语句或整个程序
- 一个应用程序可以包含多个事务

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2021.png)

**事务的性质（ACID）**

- 原子性
    
    ![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2022.png)
    
- 一致性
    
    ![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2023.png)
    
- 隔离性
    
    ![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2024.png)
    
- 持续性
    
    ![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2025.png)
    

**事务并发**

- I/O与CPU可以并行交叉运行
- 并发执行的优点
    - 改善系统的资源利用率
    - 减少短事务的等待时间
- 调度
    - 一个或多个事务的操作按时间排序的一个序列
    - 一个事务的两个操作（读、写）在调度中出现的顺序必须与其在事务内定义的先后顺序一致

**（不受控制）事务并发带来的问题：隔离性被破坏**

- 丢失更新（某事务更新的内容被并行事务覆盖）
- 读脏数据（读未提交的数据）
- 不可重复读（两次读到的结果不一致）
- 幻读（事务T1的两次读取数据之间，其它事务进行了插入删除操作，以致两次读到的记录数不同）

**数据库事务隔离：串行或并行但控制**

- 读未提交：一个事务可以读取另一个未提交事务的数据
- 读提交：一个事务等另一个事务提交后读取数据
- 重复读：开始读取数据（事务开启）时，不再允许修改
- 序列化：串行化执行

| 隔离级别 | 丢失更新 | 读脏数据 | 不可重复读 | 幻读 |
| --- | --- | --- | --- | --- |
| 读未提交 | 是 | 否 | 否 | 否 |
| 读提交 | 是 | 是 | 否 | 否 |
| 重复读 | 是 | 是 | 是 | 否 |
| 序列化 | 是 | 是 | 是 | 是 |

## 7.2 可串行化调度

**串行调度：** 不同事务的活动在调度中是一个接一个执行的，没有交叉的运行

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2026.png)

**可串行化调度**

- 调度是可串行化的：多个事务交叉调度的结果与某一个串行调度的结果相同
- 一个调度如果是可串行化的，系统认为其调度是一个正确的调度，保持了数据库的一致性

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2027.png)

**调度表示**

- 简记符号
    - WRITE→W
    - READ→R
    - WT(X)：事务T写数据库元素X
    - RT(X)：事务T读数据库元素X
    - S：表示一个调度
- 调度（事务序列）表示
    
    S=R1(A)R2(A)W1(A)W2(A)R2(B)R1(B)W2(B)W1(B)
    

**指令冲突：** 对同一数据对象操作，两个操作指令中有一个写W

- 读相同数据：不冲突
- 读写相同数据：冲突
- 写相同数据：冲突
- 读写不同数据：冲突

示例

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2028.png)

**冲突等价**

若调度S中属于不同事务的两条指令操作是不冲突的，则可以交换两条指令的执行顺序，得到一个新的调度S’。称调度S与调度S’冲突等价。

**冲突可串行化**

若一个调度冲突等价于一个串行调度，则该调度是冲突可串行化的。

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2029.png)

S’是冲突可串行化的。

**冲突可串行化判定**：前驱图

若前驱图存在环，则表示调度S是不可串行化的；若不存在环，则调度S是冲突可串行化的。

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2030.png)

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2031.png)

**视图等价**

对同一事务集，如果两个调度S1和S2在任何时候都保证每个事务读取相同的值，写入数据库的最终状态也是一样的，则称调度S1和S2视图等价。

例1：

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2032.png)

例2：

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2033.png)

**视图可串行化**

- 如果某个调度视图等价于一个串行调度，则称这个调度是视图可串行化的
- 如果调度是冲突可串行化的，则该调度一定是视图可串行化的，反之未必成立

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2034.png)

## 7.3 基于锁的并发控制

**封锁**

- 指事务在对数据库进行读、写操作之前，必须先得到对操作对象的控制权力
- 先要对将执行读、写操作的数据库对象申请锁，在获得该数据库对象的控制权力后，才能进行相应的读、写操作
- 封锁是实现数据库并发控制的重要手段

**锁管理器**

- 事务执行过程中锁的申请和释放由DBMS中的锁管理器负责
- 锁管理器维护一张哈希表——锁表
- 对每个数据库对象，如果其上有锁，那么锁表指明持有该锁的事务
- 锁表包含的信息有：每个数据库对象上已有锁的个数、锁类型以及一个指向申请锁队列的指针

**锁的类型**

- 共享锁（S锁）：如果事务T申请到数据项Q的共享锁，则T可以读数据项Q，但不能写Q
- 排它锁（X锁）：如果事务T申请到数据项Q的排它锁，则T可以读写数据项Q

**锁的相容性**

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2035.png)

**锁的申请**

当事务需要操作数据时，它向锁管理器发出锁申请

- 若申请的是一个共享锁，且申请队列为空，当前数据项上也没有排它锁，则锁管理器授予锁，并修改数据项的锁表。
- 若申请的是一个排它锁，当前也没有其它的事务拥有该数据项上的锁，则锁管理器授予锁，并修改数据项的锁表。
- 否则，申请的锁不能马上授予，锁申请加入申请队列，申请锁的事务挂起。

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2036.png)

**锁的升级与更新锁**

- 锁的升级有可能使得出现死锁的概率加大（更新锁可升级，共享锁不可升级）
- 更新锁只允许事务读取数据项而不能修改数据
- 更新锁代表该资源将在稍后更新
- 需要更新的数据时，更新锁直接转为排他锁，不需要等待其他事务释放共享锁
- 系统允许更新锁升级，而不允许共享锁升级

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2037.png)

**锁的三级封锁**

一级封锁：修改数据加X锁直到事务解锁后才释放。（解决丢失更新）

二级封锁：在一级封锁基础上，添加：T事务在读取数据R之前必须先对其加上S锁，读完释放S锁。

三级封锁：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务解锁后才释放。

**两阶段锁协议**

- 所有事务分两个阶段提出加锁和解锁申请
1. 增长阶段：在对任何数据进行读、写操作之前，首先申请并获得该数据的封锁
2. 收缩阶段：在释放一个封锁后，事务不再申请和获得其它的任何封锁
- 两段锁协议是保证冲突可串行化的充分条件，但该协议不保证不发生死锁

严格两阶段锁：除满足两段锁协议外，要求事务的排它锁在事务提交后释放，解决级联回滚问题

强两阶段锁：除满足两段锁协议外，要求所有锁在事务提交后释放

# 第八章 故障恢复

## 8.1 数据库恢复技术

**故障解决**

- 尽可能提高系统的可靠性
- 在系统发生故障后，把数据库恢复到一致状态

**恢复技术**

- 记录日志文件
- 数据转储

**日志**

日志是用来记录事务对数据库的更新操作的文件，是日志记录的序列

- 事务标识符：执行写操作事务的唯一标识符
- 数据项标识符：事务操作对象的唯一标识符
- 前像（BI）：更新前数据的旧值
- 后像（AI）：更新后数据的新值

**日志记录形式**

- <T START>：事务T开始
- <T COMMIT>：事务T提交
- <T ABORT>：事务T不能成功完成，中止
- <T,X,V1,V2>：事务T对数据项X执行写操作，写之前的旧值为V1，写之后的新值为V2

**日志要求**

- 每次事务执行写操作，必须在数据库修改前建立此写操作的日志记录
- 日志必须保存在稳定存储器上
- 稳定存储器中的日志记录顺序必须与写入日志缓冲区中的日志记录顺序完全一样
- 在主存中的数据块输出到数据库前，所有与该数据块中数据有关的日志记录必须已输出到稳定存储器上

**写日志方法：** 后像后写、后像前写、后像前后写

**后像后写**

事务执行时，后像（AI）在事务提交后才写入数据库

- 日志中记录所有的数据库修改
- 一个事务的所有写操作延迟到事务的操作结束时才执行，保证事务原子性

> 在T开始执行前，向日志中写入记录<T START>
> 
> 
> T的一次write（X）操作导致向日志中写入一条新记录
> 最后，当T全部操作结束，向日志中写入记录<T COMMIT>
> 

**简化日志内容**：日志记录<T,X,V1>：事务T对数据项X执行写操作，写入新值V1

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2038.png)

**事务恢复**

- 忽略未完成的事务；重复已提交事务的影响
- 恢复过程Redo(Ti)：将事务Ti更新的所有数据项的值设为新值

**恢复步奏**

1. 从后向前扫描日志，将提交的事务放入队列redo-list
2. 从前往后扫描日志，对遇到的每一<T,X,V1>记录
    1. 如果T不是redo-list中的事务，什么也不做
    2. 如果T是redo-list中的事务，则为数据项X写入值V1
3. 对每个未完成的事务，在日志中写入<T,ABORT>记录并刷新日志

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2039.png)

**后像前写**

后像（AI）在事务提交前完全写入数据库

- 在日志中记录所有的数据库修改，一个事务的所有写操作在事务提交前已写入磁盘
- 在恢复时忽略已提交的事务；撤销未提交事务的影响
- 日志先写：如果事务T改变了数据项X，则记录变化的日志记录必须在数据项的新值写到磁盘前写入稳定的存储器
- 如果事务提交，则<T COMMIT>日志记录必须在事务改变的所有数据项的新值写入到磁盘后再写入稳定的存储器，但应尽快

> 在T开始执行前，向日志中写入记录<T, START>
> 
> 
> T的一次write（X）操作导致向日志中写入一条新记录
> 当T全部操作结束，被改变的所有数据项已写入磁盘后向日志中写入记录<T, COMMIT>
> 

**简化日志内容：** 日志记录<T,X,V1>表示：事务T对数据项X执行写操作，写前的旧值为V1

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2040.png)

**事务恢复**

undo(Ti)：将事务Ti更新的所有数据项的值设为旧值

**恢复步骤**

1. 对日志文件从后往前扫描，将有<T,COMMIT>记录的事务放入redo-list队列
2. 对日志从后向前扫描
    1. 对遇到的每一个<T,X,V1>记录，若事务T在redo-list队列中，则恢复管理器什么也不做
    2. 若事务T在redo-list中，则恢复管理器将数据项X在数据库中的值改为旧值V1

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2041.png)

**后像前后写**

后像（AI）在事务提交前后写入数据库

- 被修改数据项写入磁盘的时间可以在日志记录<T,COMMIT>之前进行，也可以放在之后进行
- 写入的更新日志记录由4部分组成。日志记录<T,X,V1,V2>表示：事务T对数据项X执行写操作，写前的旧值为V1，写后的新值为V2

> 日志先写——被更新数据项写入磁盘前，更新记录<T，X，V1，V2>必须已写到稳定存储器上
> 

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2042.png)

**事务恢复**

Undo(Ti)：将未提交事务Ti更新的所有数据项的值设为旧值

Redo(Ti)：将已提交事务Ti的所有数据项的值设为新值

**恢复步骤**

1. 对日志文件从后向前扫描，将有<T,COMMIT>记录和没有<T,COMMIT>记录的事务分别放入redo-list、undo-list
2. 从前向后扫描日志记录，从新执行redo-list中的事务
3. 从后向前扫描日志记录，撤销undo-list队列中的事务

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2043.png)

**等幂操作**

- 多次执行与执行一次效果完全相同
- 无论回滚(Undo)操作还是重做(Redo)操作，恢复步骤都是等幂的
- 当系统从上一次崩溃中恢复时再次发生崩溃，恢复机制仍可再次重复恢复过程，前一次恢复无关紧要

**检查点**

系统定期或不定期建立检查点，保存数据库状态。

**提交一致性检查点**

- 新的事务不能开始直到检查点完成
- 现有的事务继续执行直到提交或中止，并且相关数据都写入稳定存储器
- 将当前日志缓冲区中的日志记录写回稳定存储器中的日志文件
- 将日志记录<checkpoint>写入稳定存储器

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2044.png)

**高速缓存一致性检查点**

- 新的事务不能开始直到检查点完成
- 已存在的事务不允许执行新的更新操作，如写缓冲块或写日志记录
- 将当前日志缓冲区中的日志记录写回稳定存储器中的日志文件
- 将当前数据缓冲区中的所有数据记录写入磁盘
- 将日志记录<checkpoint，L>写入稳定存储器，其中L是所有活动事务的列表

**数据转储**

- 定期地将整个数据库复制到某种存储介质（如磁带、磁盘、光盘等）上保存起来的过程
- 备用的数据文本称为后备副本或后援副本
- 数据转储是数据库恢复中采用的基本技术

**分类**：静态转储与动态转储，完全转储与增量转储

**静态转储**

- 在系统中无运行事务时进行转储
- 转储开始时数据库处于一致性状态
- 转储期间不允许对数据库的任何存取、修改活动

优点：实现简单

缺点：降低了数据库可用性（转储必须等用户事务结束，新的事务必须等转储结束）

**动态转储**

- 转储操作与用户事务并发进行
- 转储期间运行对数据库存取或修改

优点：不用等正在进行的用户事务结束，不会影响新事务的进行

缺点：不能保证副本中的数据正确有效

**完全转储**

每次转储全部数据库。

**增量转储**

只转储上次转储后更新过的数据。

从恢复角度看，使用完全转储得到的后备副本进行恢复往往更方便。但如果数据库很大，事务处理又十分频繁，则增量转储方式更实用更有效

## 8.2 故障种类及恢复策略

**故障分类**

1. 事务故障
    - 逻辑错误：事务由于内部条件（非法输入）无法继续正常运行
    - 系统错误：系统进入不良状态（死锁），事务无法继续正常执行
    - 事务故障使得事务无法达到预期的终点，数据库可能处于不一致状态。恢复机制强行回滚该事务，撤销该事务对数据库做的任何修改
2. 系统故障
    - 包括硬件故障、数据库软件或操作系统的漏洞造成的系统停止运转。它导致系统易失性存储器的内容丢失，事务处理停止，但非易失性存储器内容不受破坏
3. 介质故障
    - 在数据传送操作过程中由于磁头损坏或故障造成磁盘块上的内容丢失
    - 需使用其他非易失性存储器上的数据库后备副本进行故障恢复

**故障恢复**

1. 事务故障恢复
    1. 利用日志文件（后像后写，后像前写，后像前后写）
2. 系统故障恢复
    1. 利用日志文件
    2. 当系统崩溃重新启动时，它构造两个队列：undo-list存放需要撤销的事务标识符，redo-list存放需要重做得事务标识符，这两个队列刚开始时都是空的。
    3. 队列构造步骤如下
    •系统反向扫描日志，直到发现第一个<checkpoint>记录
    •对每一个<Ti，COMMIT>记录，将Ti加入redo-list
    •对每一个<Ti，START>记录，如果Ti不属于redo-list，则将Ti加入undo-list
    - 具体过程
        
        ![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2045.png)
        
        ![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2046.png)
        
3. 介质故障恢复
    1. 装入最近的完全转储后备副本
    •若数据库副本是动态转储的，还需要同时装入转储开始时刻的日志文件副本，利用恢复系统故障的方法将数据库恢复到某个一致性状态
    2. 如果有后续的增量转储，按照从前往后的顺序，根据增量转储来修改数据库
    3. 装入转储结束后的日志文件副本，重做已完成的事务
    •首先反向扫描日志文件，找出故障发生时已经提交的事务，将事务标识符写入redo-list
    •然后正向扫描日志文件，对redo-list中的所有事务进行redo操作

# 第九章 数据库安全

## 9.1 数据库安全概述

<aside>

数据共享必然带来数据库的安全性问题;

只允许有合法使用权限的用户访问允许他存取的数据;

数据库系统的安全保护措施是否有效是数据库系统主要的指标;

数据库的安全性和计算机系统的安全是紧密联系、互相支持的.

</aside>

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2047.png)

**三类安全问题**：技术安全类、管理安全类、政策法律类

**数据库系统的安全框架**

- 网络系统层次
    - 物理层面避免入侵者物理破坏；
    - 网络层面利用防火墙、入侵检测等手段阻止外部入侵
- 操作系统层次
    - 操作系统安全策略、安全管理策略和数据安全
- 数据库系统层次
    - 用户标识和鉴别、存取控制、数据分级、视图机制、审计、数据加密

## 9.2 自主访问控制（DAC）

主体S

- 提出访问资源具体请求，是某一操作动作的发起者
- 可能是某一用户，也可以是用户启动的进程、服务和设备等

客体O

- 被访问资源的实体，所有可以被操作的信息、资源、对象都可以是客体
- 客体可以是信息、文件、记录等集合体，也可以是网络上硬件设施

控制策略A

- 主体对客体的相关访问规则集合，即属性集合
- 访问策略体现了一种授权行为，也是客体对主体某些操作行为的默认

自主访问控制

- 控制方式是自主的，可由客体的属主对自己客体进行管理
- 可以在主体之间相互转让权限的访问控制

**权限**

访问数据的权限

- SELECT（读取权限）：允许读数据，但不能修改数据
- INSERT（插入权限）：允许插入一条新的数据，但不能修改已有数据
- UPDATE（修改权限）：允许修改数据，但不能删除数据
- DELETE（删除权限）：允许删除数据

修改数据库模式的权限

- Index（索引权限）：允许建立或删除索引
- Create（创建权限）：允许建立新的关系表
- Alter（修改权限）：允许对关系表的属性进行增加、删除
- Drop（删除权限）：允许删除关系表

其他权限

- CONNECT权限：允许用户连接数据库
- REFERENCE权限：允许用户在建立关系的完整性约束中引用一个参照关系
- USAGE权限：授权用户使用一个指定的域
- TRIGGER权限：授权用户定义关系表中触发器的权利
- EXECUTE权限：授予用户执行一个函数或过程的权利
- UNDER权限：授权用户建立一给定类的子类

权限示例

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2048.png)

**授权**

对象创建者拥有所有权限。授权可以由DBA授予，也可以由数据对象的创建者授予。

**授权格式：**

```sql
GRANT{all privileges|privilege{...}}
ON[TABLE]tablename|viewname
TO[PUBLIC|user_name{,user_name...}]
[WITH GRANT OPTION]
```

**授权粒度：** 指可以定义的数据对象的范围，范围越小越灵活，但开销变大

- 数据库
- 表
- 属性列
- 行

授权示例：

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2049.png)

**视图授权**

- 对视图也应可以授权
- 要授予其他用户与访问视图相关的权利，授权者必须拥有该视图（而且在视图所引用基本表或视图上有必要的权限）或已经通过WITH GRANT OPTION被授予了这些权限
- 若要在一个视图上授予插入、删除或更新权限，视图必须是可更新的
- 用户要建立视图，首先必须要有对所引用基本表或视图的SELECT权利

**收回权限格式：**

```sql
REVOKE [WITH GRANT OPTION FOR]{ALL PRIVILEGES|privilege{. Privilege….}}
ON [TABLE] tablename|viewname
FROM [PUBLIC|user_name{,user_name…}]
[RESTRICT|CASCADE]
```

从一个用户那里收回权限可能导致其他用户也失去该权限。这一行为称为级联回收CASCADE。在大多数数据库系统中，级联回收是默认行为。

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2050.png)

**授权图**

- 用授权图来表示授权在用户之间的传递
- 图中的结点表示用户，如果用户Ui将权限传递给了Uj，则在图中增加一条边Ui→Uj。图的根是DBA 或对象创建者
- 用户具有授权当且仅当存在从授权图的根到代表该用户的结点的路径

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2051.png)

**基于角色授权（RBAC）**

RBAC方法

- 根据管理中相对稳定的职权和责任来划分角色
- 将访问许可权分配给一定的角色
- 用户通过饰演不同的角色获得访问许可权

**角色作用**

- 角色可以看作是一组操作的集合，不同的角色具有不同的操作集
- 角色是访问控制中访问主体和受控对象之间的一座桥梁（授权模板）

角色与用户关系

- 一个用户可经授权而拥有多个角色，一个角色可有多个用户组成

角色与许可关系

- 每个角色拥有多种许可，每个许可也可以授权给多个不同的角色，每个操作可施加与多个客体，每个客体可接受多个操作

**角色操作**

```sql
-- 创建角色
CREATE ROLE Admin;

-- 角色授权
GRANT SELECT ON RecipeMaster TO Admin;

-- 角色授权用户或其他角色
GRANT Admin TO LiXia;
GRANT ROLE Manager;
GRANT Admin to Manager;
GRANT Manager TO WangHao;
-- Manager继承了Admin具有的权限
```

## 9.3 强制访问控制（MAC）

**强制访问控制（MAC）的特征**

- 对所有主体（系统中的活动实体，如用户）及其控制的客体（如进程、文件、基表、视图等）实施强制访问控制
- B1级，严格
- 每一个数据对象被标以一定的密级，每一个用户也被授予某一个级别的许可证，对于任意一个对象，只有具有合法许可证的用户才可以存取

**敏感度标记**

- 对于主体和客体，DBMS为它们每个实例（值）指派一个敏感度标记
- 敏感度标记级别：绝密，机密，可信，公开
- 主体的敏感度标记称为许可证级别，客体的敏感度标记称为密级
- MAC机制就是通过对比主体的Label和客体的Label，最终确定主体是否能够存取客体

**强制存取控制规则**

- 仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体
- 仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2052.png)

**MAC与DAC**

- DAC与MAC共同构成DBMS的安全机制
- 先进行DAC检查，通过DAC检查的数据对象再由系统进行MAC检查
- 只有通过MAC检查的数据对象方可存取

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%20da731fd219144922bef22ea832bf7d3c/Untitled%2053.png)
